[
{
	"uri": "https://rl89pl.github.io/pl/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/tags/django/",
	"title": "Django",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/categories/django/",
	"title": "Django",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/series/django-quick-tips/",
	"title": "Django - quick tips",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/posts/django_tips_0/",
	"title": "Django - Quick Tips - Templatetags",
	"tags": ["Python", "Django"],
	"categories": [],
	"series": ["Django - quick tips"],
	"description": "Django - quick tips - Start",
	"content": "Django - Quick Tips Rozpoczynam nową serię z drobnymi poradami dotyczącymi Django.\nNa początek serii napiszę i omówię dość przydatny templatetag, który ułatwi pracę z paginacją i różnym filtrowaniem/sortowaniem na stronie.\nProblem\nNa stronie masz paginator, a także sortowanie, bądź filtrowanie treści. Klikasz, by filtrować treść i chcesz przejść na kolejną stronę, a tu\u0026hellip; jesteś co prawda na kolejnej stronie, ale bez wybranego filtrowania.\nTemplate Tag Przygotowanie\nW folderze aplikacji django, gdzie są pliki m.in. views.py, models.py tworzymy moduł, czyli tworzymy folder templatetags a w nim plik __init__.py, oraz url_tag.py.\nEdycja url_tag.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  from django import template register = template.Library() @register.simple_tag(takes_context=True) def url_add(context, **kwargs): request = context.get(\u0026#39;request\u0026#39;) get = request.GET.copy() for kwarg in kwargs: get.pop(kwarg, None) get.update(kwargs) path = f\u0026#34;{request.path}?\u0026#34; path += get.urlencode() return path   Użycie tagu\nBy użyć tagu {% url_add %}, musimy go zarejestrować na początku templatu\n{% load url_tag %}\rNastępnie w przypadku paginacji zamiast:\n1  \u0026lt;a href=\u0026#34;{% url_add page=i %}\u0026#34;   wstawiamy:\n1  \u0026lt;a href=\u0026#34;{% url_add page=i %}\u0026#34;   Jeśli chcemy powiązać tag z formularzem, by np. łączyć zapytania z filtrowaniem, bądź sortowaniem, to podajemy tag w form action:\n1  \u0026lt;form action=\u0026#34;{% url_add %}\u0026#34;   Dzięki temu adres url może wyglądać następująco:\nhttps://moja-strona.pl/news/?category=3\u0026amp;category=4\u0026amp;page=2\r"
},
{
	"uri": "https://rl89pl.github.io/pl/tags/python/",
	"title": "Python",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/",
	"title": "Robert Lewandowski",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/posts/",
	"title": "Wpisy",
	"tags": ["index"],
	"categories": [],
	"series": [],
	"description": "Strona z wpisami",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/categories/projekt/",
	"title": "Projekt",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/series/todo/",
	"title": "ToDo",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/posts/todo_0/",
	"title": "ToDo APP - opis projektu",
	"tags": [],
	"categories": [],
	"series": ["ToDo"],
	"description": "Opis projektu aplikacji typu TODO",
	"content": "Dostępne aplikacje Używałem wielu aplikacji do planowania zadań i jeszcze więcej testowałem.\nPrzykładowo w każdej można utworzyć listę zadań, np.:\n Zakup słuchawek Trening Sprzątanie piwnicy  W wielu z nich można także ustalić ile dane zadanie zajmie nam czasu i na podstawie tego planować dzień.\nProblem i rozwiązanie Nie przypominam sobie jednak, by jakakolwiek z nich miała opcję predefiniowanych podzadań.\nOczywiście wiele z nich miało możliwość dodawania podzadań, ale trzeba je uzupełniać za każdym razem, gdy dodaje się główne zadanie.\nProblemem jest to, że zadanie np. Trening jest niekompletne.\nDobrze byłoby mieć już wszystko skonfigurowane tak, że gdy doda się takie zadanie do listy, to dodawałyby się automatycznie podzadania, np.:\n Spakować strój sportowy Zabrać ze sobą wodę Spakować ręcznik kąpielowy Spakować ręczniik na sprzęt  Przy wyznaczaniu czasu w zadaniach też warto uwzględnić np. przejazdy do i z siłowni, oraz przebranie się + prysznic.\nNie zawsze o tym się pamięta, gdy ma się tylko zapis \u0026ldquo;trening\u0026rdquo; i zapewne każdy wpisuje przybliżony czas samego treningu :)\nGdyby dodać predefiniowane zadania, można byłoby ustawić sobie taski pod konkretny rodzaj treningu wraz z ćwiczeniami i nie trzeba za każdym razem tego dodawać.\nStrasznie uciążliwe byłoby dodawać na nowo ćwiczenia w treningu typu Split, gdzie mamy podział na PUSH, PULL i LEGS.\nProjekt Ogólne założenia:\n dobrze, gdyby aplikacja była multiplatformowa, ponieważ samo planowanie wolę wykonywać na desktopie, ale już przy oznaczaniu wykonanych zadań nie chcę się ograniczać i wolę do tego apkę mobilną jeżeli aplikacja ma być multiplatformowa, to musi posiadać też REST API, tym bardziej, że wiele predefiniowanych zadań będę chciał dodać automatem (np. rodzaje treningów)  Stack technologiczny:\n frontend - Vue/Angular/React backend - Django mobile: Flutter  Na pewno będę chciał przetestować nowe możliwości Fluttera jeśli chodzi o desktopowe aplikacje, ale to taki raczej bonus.\n"
},
{
	"uri": "https://rl89pl.github.io/pl/posts/hackyeah/",
	"title": "Hackyeah",
	"tags": ["Python", "Django"],
	"categories": [],
	"series": ["Scam Base"],
	"description": "Projekt z hackathonu Hackyeah",
	"content": "Hackyeah Summer June Edition Brałem udział w kolejnej edycji jednego z największych hackathonów w Europie.\nSamodzielnie rozpocząłem projekt na tyle według mnie ciekawy, że postanowiłem go kontynuować już po zakończeniu tego hackathonu.\nProjekt Ogólne zasady:\n"
},
{
	"uri": "https://rl89pl.github.io/pl/series/scam-base/",
	"title": "Scam Base",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/series/automatyzacja/",
	"title": "Automatyzacja",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/categories/automatyzacja/",
	"title": "Automatyzacja",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/posts/automatyzacja_projektow/",
	"title": "Automatyzacja projektow",
	"tags": ["Python", "Windows", "Produktywność"],
	"categories": [],
	"series": ["Automatyzacja"],
	"description": "Skrypty automatyzujące rozpoczęcie nowego projektu",
	"content": "Wprowadzenie Trzeba szanować swój czas i w miarę możliwości automatyzować wszystko, co jest uciążliwe, monotonne, często powtarzalne. Postanowiłem ułatwić sobie pracę przy tworzeniu nowego projektu, a także szybkie rozpoczęcie pisania nawet testowego skryptu.\nPrzy tworzeniu projektu musiałbym wpierw utworzyć odpowiedni folder, zalogować się na github.com w celu utworzenia repozytorium, zainicjowanie go, utworzenie pliku README i przesłanie na platformę github. Dodatkowo utworzenie pustego pliku python i uruchomienie VS Code.\nTrochę to czasu zajmuje, a gdyby to wszystko zastąpić wyłącznie komendą w cmd, lub powershell w formie komendy z dowolnego miejsca w systemie?\n1  pro.py Projekt   Ułatwienie niesamowite, dlatego czas zająć się tym.\nRepozytorium projektu: Auto_create\nUruchamianie skryptów Aby uruchomić skrypt z dowolnego miejsca w systemie należy lokalizację folderu dodać do PATH - zmiennych środowiskowych systemu Windows.\nProponuję utworzyć folder, gdzie będą znajdować się wszystkie skrypty, które chcemy uruchomić w ten sposób.\n W pierwszej kolejności w Panelu sterowania wybieramy System:\n Następnie klikamy w Zmienne środowiskowe:\n Wybieramy Path i edytujemy:\n Dodajemy nowy wpis i podajemy pełną ścieżkę do folderu   Ważne, by ustawić uruchamianie plików .py bezpośrednio przez Python (właściwości -\u0026gt; uruchamiany jako Python)\nSkrypt do tworzenia projektów Zgodnie z tym, co wypisałem na początku, chcemy utworzyć folder z nowym projektem, utworzyć repozytorium, przesłać go do githuba, oraz utworzyć pliki readme i skryptu wraz z otwarciem VS Code w folderze.\nDo tworzenia miejsca dla naszego repozytorium na githubie, przyda nam się biblioteka PyGithub\npip install PyGithub\nImportujemy potrzebne biblioteki i tworzymy zmienne zawierające dane do logowania na platformę github, oraz lokalizację folderu, gdzie trafiać będą wszystkie nasze utworzone projekty.\n1 2 3 4 5 6 7  import sys import os from github import Github init_path = \u0026#34;C:\\\\Projekty\\\\\u0026#34; # folder z projektami username = \u0026#34;XYZ\u0026#34; # login github password = \u0026#34;12345\u0026#34; # hasło github   Chcemy mieć możliwość szybkiego tworzenia projektów, dlatego nazwę będziemy przekazywać argumentem, przy uruchamianiu skryptu. Dodamy oczywiście opcję defaultową, by tworzył projekt z ustaloną na starcie nazwą, gdybyśmy nie podali argumentu.\nTworzymy folder i \u0026ldquo;przechodzimy\u0026rdquo; do jego lokalizacji:\n1 2 3 4 5  folder = \u0026#34;Projekt_X\u0026#34; if len(sys.argv) \u0026gt; 1: folder = sys.argv[1] os.mkdir(path) os.chdir(path)   Na swoim koncie na Githubie tworzymy nowe repozytorium\n1 2  user = Github(username, password).get_user() repo = user.create_repo(folder)   I standardowo inicjujemy lokalne repozytorium, tworzymy plik README.md i przesyłamy do wcześniej utworzonego repo na Githubie:\n1 2 3 4 5 6 7 8 9  os.system(\u0026#34;git init\u0026#34;) os.system(\u0026#34;git remote add origin https://github.com/UŻYTKOWNIK/{}.git\u0026#34;.format(folder)) with open(\u0026#34;README.md\u0026#34;,\u0026#34;w\u0026#34;) as f: f.write(\u0026#34;### \u0026#34;+folder) os.system(\u0026#34;git add .\u0026#34;) os.system(\u0026#39;git commit -m \u0026#34;pierwszy commit\u0026#34;\u0026#39;) os.system(\u0026#34;git push -u origin master\u0026#34;) open(\u0026#34;main.py\u0026#34;,\u0026#34;w\u0026#34;).close() os.system(\u0026#34;code .\u0026#34;)   Na koniec tworzymy pusty plik Python i uruchamiamy folder z projektem w VS Code:\n1 2  open(\u0026#34;main.py\u0026#34;,\u0026#34;w\u0026#34;).close() os.system(\u0026#34;code .\u0026#34;)   Zapisujemy skrypt w folderze, który na początku dodaliśmy do Path. Od teraz będzie możliwe uruchamianie z dowolnego miejsca w systemie skryptu poleceniem:\nnazwa_skryptu.py NAZWA_PROJEKTU\nSkrypt do szybkiej pracy z kodem Bardzo często nie chcemy tworzyć dużego projektu z repozytorium na githubie, lecz tylko rozpocząć kodowanie z małym skryptem.\nProsty skrypcik będzie okrojoną wersją poprzedniego:\n1 2 3 4 5 6 7 8 9 10 11  import sys import os init_path = \u0026#34;C:\\\\Skrypty\\\\\u0026#34; # folder ze skryptami folder = \u0026#34;Skrypt_X\u0026#34; if len(sys.argv) \u0026gt; 1: folder = sys.argv[1] path = init_path + folder os.mkdir(path) os.chdir(path) open(\u0026#34;run.py\u0026#34;,\u0026#34;w\u0026#34;).close() os.system(\u0026#34;code .\u0026#34;)   "
},
{
	"uri": "https://rl89pl.github.io/pl/tags/produktywno%C5%9B%C4%87/",
	"title": "Produktywność",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/tags/windows/",
	"title": "Windows",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/series/car-manager/",
	"title": "Car Manager",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/posts/wersja_konsolowa/",
	"title": "Car manager - wersja konsolowa cz.1",
	"tags": ["Python"],
	"categories": [],
	"series": ["Car Manager"],
	"description": "Tworzenie wersji konsolowej aplikacji.",
	"content": "Wprowadzenie gantt\rsection Car Manager\rSkrypt + baza danych :active, des1, 2020-01-14,2020-01-16\rDjango : des2, after des1, 2d\rDesktop app : des3, after des2, 2d\rMobile app : des4, after des3, 2d\rCzas na rozpoczęcie pracy nad pierwszą wersją aplikacji, wpierw konsolowej napisanej w Pythonie.\nBaza danych w prostym SQlite.\nRepozytorium projektu: Car Manager\nPraca z bazą danych Przy uruchamianiu programu chcemy, aby pokazał się aktualny stan pojazdu.\nCzyli w pierwszej kolejności musimy odczytać z bazy danych interesujące nas tabele, a jeśli jej nie ma, to utworzyć nową bazę.\nSprawdzamy, czy w folderze z programem jest plik bazy danych carmng.db i czy można go odczytać.\nJeżeli go nie ma, wywołujemy funkcję, która będzie tworzyła bazę danych:\n1 2 3 4 5 6 7 8 9 10  import os import sqlite3 from sqlite3 import Error def main(): database = \u0026#34;carmng.db\u0026#34; if not os.access(database, os.R_OK): #jeżeli nie ma pliku, tworzy bazę danych z dwiema tabelami connection = sqlite3.connect(database) create_table(connection)   Tworzymy tabelę w bazie przeznaczoną dla informacji o autach i odrębną o statystykach (tankowania, koszty, etc.):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  def create_table(connection): sql_create_car_table = \u0026#34;\u0026#34;\u0026#34; CREATE TABLE IF NOT EXISTS car ( id integer PRIMARY KEY AUTOINCREMENT UNIQUE, nazwa text NOT NULL, marka text, rocznik text ); \u0026#34;\u0026#34;\u0026#34; sql_create_stats_table = \u0026#34;\u0026#34;\u0026#34;CREATE TABLE IF NOT EXISTS stats ( id integer PRIMARY KEY AUTOINCREMENT UNIQUE, data text, godzina text, licznik_km integer, cena numeric, ilosc_litrow integer, koszt integer, do_pelna integer, car_id integer NOT NULL, FOREIGN KEY (car_id) REFERENCES car (id) );\u0026#34;\u0026#34;\u0026#34; try: cursor = connection.cursor() cursor.execute(sql_create_car_table) cursor.execute(sql_create_stats_table) cursor.close() except Error as e: print(e) finally: if (connection): connection.close()   Gdy baza już jest, wywołamy funkcję do odczytu danych z bazy, dla konkretnego auta:\n1  showAuto(database)   Teraz trzeba wyświetlić rekordy:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  def showAuto(database): try: connection = sqlite3.connect(database) cursor = connection.cursor() select_query = \u0026#34;\u0026#34;\u0026#34;SELECT * from car\u0026#34;\u0026#34;\u0026#34; cursor.execute(select_query) records = cursor.fetchall() print(\u0026#34;Ilość rekordów: \u0026#34;, len(records)) for row in records: print(\u0026#34;Id: \u0026#34;, row[0]) print(\u0026#34;Nazwa: \u0026#34;, row[1]) print(\u0026#34;Marka: \u0026#34;, row[2]) print(\u0026#34;Rocznik: \u0026#34;, row[3]) print(\u0026#34;\\n\u0026#34;) cursor.close() except sqlite3.Error as error: print(\u0026#34;Błąd odczytu danych z bazy\u0026#34;, error) finally: if (connection): connection.close()   Pokażemy sobie na tę chwilę wszystkie rekordy z tabeli ze statystykami dla podanego auta:\n1  showStats(database, car_id)   Printujemy rekordy:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  def showStats(database, car_id): try: connection = sqlite3.connect(database) cursor = connection.cursor() print(car_id) select_query = \u0026#34;\u0026#34;\u0026#34;SELECT * from stats WHERE car_id = {}\u0026#34;\u0026#34;\u0026#34;.format(car_id) cursor.execute(select_query) records = cursor.fetchall() print(\u0026#34;Total rows are: \u0026#34;, len(records)) print(\u0026#34;Printing each row\u0026#34;) for row in records: print(\u0026#34;Id: \u0026#34;, row[0]) print(\u0026#34;Data: \u0026#34;, row[1]) print(\u0026#34;Godzina: \u0026#34;, row[2]) print(\u0026#34;Licznik KM: \u0026#34;, row[3]) print(\u0026#34;Cena: \u0026#34;, row[4]) print(\u0026#34;Ilość litrów: \u0026#34;, row[5]) print(\u0026#34;Koszt: \u0026#34;, row[6]) print(\u0026#34;Do pełna: \u0026#34;, row[7]) print(\u0026#34;\\n\u0026#34;) cursor.close() except sqlite3.Error as error: print(\u0026#34;Błąd odczytu danych z bazy\u0026#34;, error) finally: if (connection): connection.close()   Czyszczenie ekranu Dobrze byłoby czyścić ekran, dlatego dodam wpis (dla windowsa czyszczenie to cls pod linuxem clear):\n1  clear = lambda: os.system(\u0026#39;cls\u0026#39;)   Teraz za każdym razem, gdy będę chciał wyczyścić ekran, wystarczy, że wpiszę:\n1  clear()   Wybieralne menu Skoro mamy już rozpisane wyświetlanie, czas na dodawanie wpisów.\nNa początek wprowadzimy możliwość dodawania aut:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def addAutoToDatabase(database): nazwa = input(\u0026#34;Podaj nazwę auta: \u0026#34;) marka = input(\u0026#34;Podaj markę auta: \u0026#34;) rocznik = input(\u0026#34;Podaj rocznik auta: \u0026#34;) try: sqliteConnection = sqlite3.connect(database) cursor = sqliteConnection.cursor() sqlite_insert_query = \u0026#34;\u0026#34;\u0026#34;INSERT INTO `car` (\u0026#39;nazwa\u0026#39;, \u0026#39;marka\u0026#39;, \u0026#39;rocznik\u0026#39;) VALUES (\u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;,{})\u0026#34;\u0026#34;\u0026#34;.format(nazwa, marka, rocznik) count = cursor.execute(sqlite_insert_query) sqliteConnection.commit() print(\u0026#34;Dodano wpis do bazy danych \u0026#34;, cursor.rowcount) cursor.close() except sqlite3.Error as error: print(\u0026#34;Błąd przy dodawaniu wpisu do bazy danych\u0026#34;, error) finally: if (sqliteConnection): sqliteConnection.close()   Skoro mamy już opcję dodania aut, to czas na opcję dodania wpisów:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  def addStatDatabase(database,auto = 1): wybor_daty = False wybor_do_pelna = False while wybor_daty == False: data_dzis = input(\u0026#34;Wstawić dzisiejszą datę? T/N\u0026#34;) if data_dzis == \u0026#34;t\u0026#34; or data_dzis == \u0026#34;T\u0026#34;: data = date.today() wybor_daty = True elif data_dzis == \u0026#34;n\u0026#34; or data_dzis == \u0026#34;N\u0026#34;: data = input(\u0026#34;Podaj datę tankowania: \u0026#34;) wybor_daty = True else: wybor_daty = False godzina = input(\u0026#34;Podaj godzinę: \u0026#34;) licznik_km = input(\u0026#34;Podaj stan licznika kilometrów: \u0026#34;) cena = float(input(\u0026#34;Podaj cenę: \u0026#34;)) ilosc_litrow = float(input(\u0026#34;Podaj ilość zatankowanego paliwa: \u0026#34;)) while wybor_do_pelna == False: do_pelna = input(\u0026#34;Czy zatankowałeś do pełna? T/N\u0026#34;) if do_pelna == \u0026#34;t\u0026#34; or do_pelna == \u0026#34;T\u0026#34;: do_pelna = 1 wybor_do_pelna = True elif do_pelna == \u0026#34;n\u0026#34; or do_pelna == \u0026#34;N\u0026#34;: do_pelna = 0 wybor_do_pelna = True else: wybor_do_pelna = False koszt = cena * ilosc_litrow try: sqliteConnection = sqlite3.connect(database) cursor = sqliteConnection.cursor() sqlite_insert_query = \u0026#34;\u0026#34;\u0026#34;INSERT INTO `stats` (\u0026#39;data\u0026#39;, \u0026#39;godzina\u0026#39;, \u0026#39;licznik_km\u0026#39;, \u0026#39;cena\u0026#39;, \u0026#39;ilosc_litrow\u0026#39;, \u0026#39;koszt\u0026#39;, \u0026#39;do_pelna\u0026#39;, \u0026#39;car_id\u0026#39;) VALUES (\u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;,{},{},{},{},{},{})\u0026#34;\u0026#34;\u0026#34;.format(data, godzina, licznik_km, cena, ilosc_litrow, koszt,do_pelna, auto) count = cursor.execute(sqlite_insert_query) sqliteConnection.commit() print(\u0026#34;Dodano wpis do bazy danych \u0026#34;, cursor.rowcount) cursor.close() except sqlite3.Error as error: print(\u0026#34;Błąd przy dodawaniu wpisu do bazy danych\u0026#34;, error) finally: if (sqliteConnection): sqliteConnection.close()   Konfiguracja w pliku ini Dobrym rozwiązaniem będzie dodanie domyślnych ustawień i wpływu na nie.\nDo pracy z plikami konfiguracyjnymi, użyję modułu configparser\nNa początku chcę, bym mógł ustawić jakieś auto domyślne, by od razu pokazywały dla niego statystyki.\nDo funkcji dodawania auta, dam możliwość wyboru, czy wprowadzone auto ma być domyślne:\n1 2 3 4 5 6 7  domyslne_auto = input(\u0026#34;\\nDodać jako auto domyślne?: \u0026#34;) if domyslne_auto == \u0026#34;t\u0026#34; or domyslne_auto == \u0026#34;T\u0026#34;: config = configparser.ConfigParser() config[\u0026#39;DEFAULT\u0026#39;] = {} config[\u0026#39;DEFAULT\u0026#39;][\u0026#39;CAR_ID\u0026#39;] = str(cursor.lastrowid) with open(\u0026#39;config.ini\u0026#39;, \u0026#39;w\u0026#39;) as configfile: config.write(configfile)   Wpierw standardowo w main sprawdzę, czy jest plik .ini tak jak to było w przypadku bazy danych i wczytam ID dla domyślnego auta:\n1 2 3 4 5 6 7 8  conf = \u0026#34;config.ini\u0026#34; car_id = 1 if os.access(conf, os.R_OK): config.read(conf) config.sections() if \u0026#39;DEFAULT\u0026#39; in config: car_id = int(config[\u0026#39;DEFAULT\u0026#39;][\u0026#39;CAR_ID\u0026#39;]) clear()   Wybieralne menu By całość lepiej się prezentowała, dodamy menu wyboru poszczególnych opcji. Wykorzystamy w tym celu bibliotekę pick\n1 2  from pick import pick import sys   Do fukcji main dopiszemu sobie kod dla menu:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  wybor = input(\u0026#34;\\nWciśnij \u0026#39;Q\u0026#39;, by wyjść, lub inny dowolny klawisz by przejść dalej...\u0026#34;) clear() if wybor == \u0026#34;q\u0026#34; or wybor == \u0026#34;Q\u0026#34;: sys.exit() wyjscie = False while wyjscie == False: title = \u0026#39;Wybierz rodzaj: \u0026#39; options = [\u0026#39;Ekran główny\u0026#39;,\u0026#39;Dodaj wpis\u0026#39;,\u0026#39;Auta\u0026#39;,\u0026#39;Wyjście\u0026#39;] option1, index = pick(options, title) print(index) if index == 0: showStats(database, car_id) wybor = input(\u0026#34;\\nWciśnij \u0026#39;Q\u0026#39;, by wyjść, lub inny dowolny klawisz by przejść dalej...\u0026#34;) clear() if wybor == \u0026#34;q\u0026#34; or wybor == \u0026#34;Q\u0026#34;: wyjscie = True elif index == 1: addStatDatabase(database,car_id) wybor = input(\u0026#34;\\nWciśnij \u0026#39;Q\u0026#39;, by wyjść, lub inny dowolny klawisz by przejść dalej...\u0026#34;) clear() if wybor == \u0026#34;q\u0026#34; or wybor == \u0026#34;Q\u0026#34;: wyjscie = True elif index == 2: connection = sqlite3.connect(database) cursor = connection.cursor() select_query = \u0026#34;\u0026#34;\u0026#34;SELECT * from car\u0026#34;\u0026#34;\u0026#34; cursor.execute(select_query) records = cursor.fetchall() if len(records) \u0026lt;= 0: addAutoToDatabase(database) else: showAuto(database) dodaj_auto = input(\u0026#34;\\nDodać auto?: \u0026#34;) if dodaj_auto == \u0026#34;t\u0026#34; or dodaj_auto == \u0026#34;T\u0026#34;: addAutoToDatabase(database) wybor = input(\u0026#34;\\nWciśnij \u0026#39;Q\u0026#39;, by wyjść, lub inny dowolny klawisz by przejść dalej...\u0026#34;) clear() if wybor == \u0026#34;q\u0026#34; or wybor == \u0026#34;Q\u0026#34;: wyjscie = True elif index == 3: wyjscie = True ## po wszystkim try: if (connection): connection.close() clear() except: clear()   Koniec pierwszej części Na tę chwilę tylko dodajemy wpisy i wyświetlamy je. Kolejnym krokiem będą obliczenia, które będą wykonywane na tych danych, a na koniec refaktoryzacja kodu.\n"
},
{
	"uri": "https://rl89pl.github.io/pl/posts/car_manager/",
	"title": "Projekt - Car Manager",
	"tags": ["Python"],
	"categories": [],
	"series": ["Car Manager"],
	"description": "Projekt aplikacji pomagającej kontrolować i analizować wydatki związane z utrzymaniem samochodu.",
	"content": "Wprowadzenie Kiedyś używałem aplikacji do kontrolowania budżetu związanej z użytkowaniem auta. Bardzo praktyczne aplikacje pozwalały mi na zapisywanie przebytych tras i tankowań, dzięki czemu wiedziałem jakie koszty ponoszę miesięcznie.\nNiestety, aplikacje których używałem posiadają również wady. Gdy przez ok rok nie używałem aplikacji i do niej powróciłem, po wprowadzeniu danych odnośnie tankowania, wskazywało błędne dane w postaci 10 000 km do następnego tankowania, etc.\nPostanowiłem stworzyć własną aplikację tego typu dla własnego użytku. Wpierw będzie to skrypt obsługujący bazę danych, następnie aplikacja desktopowa, która będzie korzystać z danych z Django rest framework, a na koniec aplikacja mobilna.\nMógłbym od razu przejść do tworzenia API, by cały proces tworzenia bazy danych przeszedł niemalże automatycznie, lecz dla ćwiczeń to idealne rozwiązanie.\nRepozytorium projektu: Car Manager\nDiagram gantt\rsection Car Manager\rSkrypt + baza danych :done, des1, 2020-01-12,2020-01-14\rDjango :active, des2, after des1, 2d\rDesktop app : des3, after des2, 2d\rMobile app : des4, after des3, 2d\rKlient-\u0026gt;Program: Uruchomienie\rProgram-\u0026gt;Klient: Statystyki\rProgram-\u0026gt;Klient: Lista wyboru\rKlient --\u0026gt;Program: Wybór auta\rKlient --\u0026gt;Program: Dodanie wpisu\rKlient --\u0026gt;Program: Dodanie auta\rNote right of Program: Zgodnie z wybraną opcją\rProgram-\u0026gt;Klient: Output\rstateDiagram\r[*] --\u0026gt; Statystyki\rStatystyki --\u0026gt; Lista\rLista --\u0026gt; Dodaj_auto\rDodaj_auto --\u0026gt; Lista\rLista --\u0026gt; Wybór_auta\rLista --\u0026gt; Dodaj_wpis\rDodaj_wpis --\u0026gt; [*]\rWybór_auta --\u0026gt; Dodaj_wpis\rDodaj_wpis --\u0026gt; [*]\r"
},
{
	"uri": "https://rl89pl.github.io/pl/notes/wifi_pswd/",
	"title": "Hasła do wifi",
	"tags": ["Windows"],
	"categories": [],
	"series": [""],
	"description": "Sprawdzenie zapisanych haseł do sieci WiFi",
	"content": "Zdarza się, że potrzebujemy hasło do sieci wifi, do której się wcześniej logowaliśmy, by móc zalogować się np. w telefonie, ale nie pamiętamy hasła.\nRozwiązanie pod Windowsa jest bardzo proste. Jedyne czego potrzebujemy to cmd.\nW terminalu wpisujemy poniższe polecenie:\nnetsh wlan show profiles\rOtrzymamy listę zapisanych sieci:\nNastępnie wpisujemy poniższe polecenie, gdzie zamiast NAZWA_SIECI podajemy interesującą nas sieć:\nnetsh wlan show profiles name=NAZWA_SIECI key=clear\rNasze hasło zapisane jest pod Key Content:\n"
},
{
	"uri": "https://rl89pl.github.io/pl/notes/",
	"title": "Notatki",
	"tags": ["index"],
	"categories": [],
	"series": [],
	"description": "Notatki",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/posts/raspberry_ip/",
	"title": "IP mojego RaspberryPi",
	"tags": ["Raspberry", "Python"],
	"categories": [],
	"series": [""],
	"description": "Moje Raspberry automatycznie po uruchomieniu łączy się z VPN. Potrzebuję tylko IP. Jednym z wielu rozwiązań, będzie automat wysyłający go SMSem",
	"content": "Moje Raspberry automatycznie po uruchomieniu łączy się z VPN. Bez statycznego IP, ciężko jest wyszukać adres urządzenia, gdy nieoczekiwanie nastąpi restart, albo chwilowe rozłączenie z siecią. Jednym z wielu rozwiązań, będzie automat wysyłający SMSem swój adres IP. Dzięki takiemu rozwiązaniu mogę z każdego miejsca na ziemi połączyć się z moim Raspberry, nie zastanawiając się jakie ma IP.\nPotrzebne biblioteki By sprawdzić IP potrzebna jest biblioteka netifaces, a do wysyłania SMSów najlepszą opcją będzie Nexmo\nSkrypt Python 1 2 3 4 5 6 7 8 9  import netifaces as ni import nexmo client = nexmo.Client(key=\u0026#39;klucz\u0026#39;, secret=\u0026#39;kod\u0026#39;) a = ni.ifaddresses(\u0026#39;tap0\u0026#39;) for c, d in a.items(): for z in d: adres = z[\u0026#39;addr\u0026#39;] if \u0026#39;.\u0026#39; in adres: client.send_message({\u0026#39;from\u0026#39;: \u0026#39;Raspberry\u0026#39;, \u0026#39;to\u0026#39;: 48123456789, \u0026#39;text\u0026#39;: adres, \u0026#39;type\u0026#39;: \u0026#39;unicode\u0026#39;})   Następnie dodaję do crona odpowiednie zadania. Dzięki pierwszemu wpisowi, po restarcie łączy się z odpowiednim VPNem, a drugi uruchamia minutę po restarcie powyższy skrypt.\nZadania cron 1 2  @reboot sudo openvpn --config /etc/default/plik_vpn.ovpn @reboot sleep 60 \u0026amp;\u0026amp; /usr/bin/python3 /root/Desktop/Skrypty/send_ip.py   "
},
{
	"uri": "https://rl89pl.github.io/pl/tags/raspberry/",
	"title": "Raspberry",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/categories/skrypty/",
	"title": "Skrypty",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/tags/linux/",
	"title": "Linux",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/tags/markdown/",
	"title": "Markdown",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://rl89pl.github.io/pl/notes/md2word/",
	"title": "Markdown do Worda",
	"tags": ["Linux", "Markdown"],
	"categories": [],
	"series": [""],
	"description": "Generowanie dokumentu docx (Word) z pliku md (Markdown)",
	"content": "By móc generować dokumenty Worda z MD, należy pobrać pandoc (LINUX).\nW terminalu wpisujemy poniższe polecenie:\n1  pandoc -o output.docx -f markdown -t docx filename.md   "
},
{
	"uri": "https://rl89pl.github.io/pl/about/",
	"title": "O mnie",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Coś o sobie",
	"content": "To miejsce czeka na uzupełnienie.\nLink do GH GitHub.\n"
},
{
	"uri": "https://rl89pl.github.io/pl/posts/pierwszy_wpis/",
	"title": "Mój pierwszy wpis",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Wpisy na blogu mają posłużyć w przyszłości za swoistą bazę wiedzy. Nie oczekuję, że ktokolwiek poza mną to będzie czytał, ale jeśli z jakiegoś powodu znajdzie się jakiś czytelnik, to serdecznie witam :)",
	"content": "Wpisy na blogu mają posłużyć w przyszłości za swoistą bazę wiedzy. Nie oczekuję, że ktokolwiek poza mną to będzie czytał, ale jeśli z jakiegoś powodu znajdzie się jakiś czytelnik, to serdecznie witam :)\nDział notatek jest dla szybkich wpisów, by zapisać sobie rozwiązanie, które kiedyś może się przydać.\n \u0026ldquo;Gdybym miał osiem godzin na ścięcie drzewa, spędziłbym sześć na ostrzeniu siekiery” - Abraham Lincoln\n  \u0026ldquo;Kto nie ma pamięci, ten niech ją sobie stworzy na papierze.\u0026rdquo; - Gabriel Garcia Marquez\n "
},
{
	"uri": "https://rl89pl.github.io/pl/tags/index/",
	"title": "index",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]